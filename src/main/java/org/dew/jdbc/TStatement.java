package org.dew.jdbc;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Connection;
import java.sql.Statement;

public class TStatement implements Statement {

  protected String sTag = null;
  protected Statement statement;
  protected Tracer tracer;
  protected String sDBMS;

  public TStatement(Statement statement, String sTag, Tracer tracer, String sDBMS) {
    this.statement = statement;
    this.sTag = sTag;
    this.tracer = tracer;
    this.sDBMS = sDBMS;
  }

  public void addBatch(String sSQL) throws SQLException {
    statement.addBatch(sSQL);
  }

  public void cancel() throws SQLException {
    statement.cancel();
  }

  public void clearBatch() throws SQLException {
    statement.clearBatch();
  }

  public void clearWarnings() throws SQLException {
    statement.clearWarnings();
  }

  public void close() throws SQLException {
    tracer.traceRem("[" + sTag + ".close()]");
    try {
      statement.close();
    } catch (SQLException ex) {
      tracer.traceException(ex);
      throw ex;
    }
  }

  public boolean execute(String sSQL) throws SQLException {
    boolean bResult = false;
    tracer.traceRem("[" + sTag + ".execute]");
    tracer.trace(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      bResult = statement.execute(sSQL);
    } catch (SQLException ex) {
      tracer.traceException(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.traceRem("Elapsed: " + lElapsed + " [ms].");
    return bResult;
  }

  public boolean execute(String sSQL, int autoGeneratedKeys) throws SQLException {
    boolean bResult = false;
    tracer.traceRem("[" + sTag + ".execute]");
    tracer.trace(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      bResult = statement.execute(sSQL, autoGeneratedKeys);
    } catch (SQLException ex) {
      tracer.traceException(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.traceRem("Elapsed: " + lElapsed + " [ms].");
    return bResult;
  }

  public boolean execute(String sSQL, int[] columnIndexes) throws SQLException {
    boolean bResult = false;
    tracer.traceRem("[" + sTag + ".execute]");
    tracer.trace(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      bResult = statement.execute(sSQL, columnIndexes);
    } catch (SQLException ex) {
      tracer.traceException(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.traceRem("Elapsed: " + lElapsed + " [ms].");
    return bResult;
  }

  public boolean execute(String sSQL, String[] columnNames) throws SQLException {
    boolean bResult = false;
    tracer.traceRem("[" + sTag + ".execute]");
    tracer.trace(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      bResult = statement.execute(sSQL, columnNames);
    } catch (SQLException ex) {
      tracer.traceException(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.traceRem("Elapsed: " + lElapsed + " [ms].");
    return bResult;
  }

  public int[] executeBatch() throws SQLException {
    int[] aiResult = null;
    tracer.traceRem("[" + sTag + ".executeBatch]");
    try {
      aiResult = statement.executeBatch();
    } catch (SQLException ex) {
      tracer.traceException(ex);
      throw ex;
    }
    return aiResult;
  }

  public ResultSet executeQuery(String sSQL) throws SQLException {
    ResultSet rs = null;
    tracer.traceRem("[" + sTag + ".executeQuery]");
    tracer.trace(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      rs = statement.executeQuery(sSQL);
    } catch (SQLException ex) {
      tracer.traceException(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.traceRem("Elapsed: " + lElapsed + " [ms].");
    return rs;
  }

  public int executeUpdate(String sSQL) throws SQLException {
    int iUpdateCount = 0;
    tracer.traceRem("[" + sTag + ".executeUpdate]");
    tracer.trace(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      iUpdateCount = statement.executeUpdate(sSQL);
    } catch (SQLException ex) {
      tracer.traceException(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.traceRem(iUpdateCount + " rows affected, Elapsed: " + lElapsed + " [ms].");
    return iUpdateCount;
  }

  public int executeUpdate(String sSQL, int autoGeneratedKeys) throws SQLException {
    int iUpdateCount = 0;
    tracer.traceRem("[" + sTag + ".executeUpdate]");
    tracer.trace(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      iUpdateCount = statement.executeUpdate(sSQL, autoGeneratedKeys);
    } catch (SQLException ex) {
      tracer.traceException(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.traceRem(iUpdateCount + " rows affected, Elapsed: " + lElapsed + " [ms].");
    return iUpdateCount;
  }

  public int executeUpdate(String sSQL, int[] columnIndexes) throws SQLException {
    int iUpdateCount = 0;
    tracer.traceRem("[" + sTag + ".executeUpdate]");
    tracer.trace(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      iUpdateCount = statement.executeUpdate(sSQL, columnIndexes);
    } catch (SQLException ex) {
      tracer.traceException(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.traceRem(iUpdateCount + " rows affected, Elapsed: " + lElapsed + " [ms].");
    return iUpdateCount;
  }

  public int executeUpdate(String sSQL, String[] columnNames) throws SQLException {
    int iUpdateCount = 0;
    tracer.traceRem("[" + sTag + ".executeUpdate]");
    tracer.trace(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      iUpdateCount = statement.executeUpdate(sSQL, columnNames);
    } catch (SQLException ex) {
      tracer.traceException(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.traceRem(iUpdateCount + " rows affected, Elapsed: " + lElapsed + " [ms].");
    return iUpdateCount;
  }

  public Connection getConnection() throws SQLException {
    Connection conn = statement.getConnection();
    return new TConnection(conn, getConnectionTag(), tracer, sDBMS);
  }

  public int getFetchDirection() throws SQLException {
    return statement.getFetchDirection();
  }

  public int getFetchSize() throws SQLException {
    return statement.getFetchSize();
  }

  public ResultSet getGeneratedKeys() throws SQLException {
    return statement.getGeneratedKeys();
  }

  public int getMaxFieldSize() throws SQLException {
    return statement.getMaxFieldSize();
  }

  public int getMaxRows() throws SQLException {
    return statement.getMaxRows();
  }

  public boolean getMoreResults() throws SQLException {
    return statement.getMoreResults();
  }

  public boolean getMoreResults(int current) throws SQLException {
    return statement.getMoreResults(current);
  }

  public int getQueryTimeout() throws SQLException {
    return statement.getQueryTimeout();
  }

  public ResultSet getResultSet() throws SQLException {
    return statement.getResultSet();
  }

  public int getResultSetConcurrency() throws SQLException {
    return statement.getResultSetConcurrency();
  }

  public int getResultSetHoldability() throws SQLException {
    return statement.getResultSetHoldability();
  }

  public int getResultSetType() throws SQLException {
    return statement.getResultSetType();
  }

  public int getUpdateCount() throws SQLException {
    return statement.getUpdateCount();
  }

  public SQLWarning getWarnings() throws SQLException {
    return statement.getWarnings();
  }

  public void setCursorName(String sCursorName) throws SQLException {
    statement.setCursorName(sCursorName);
  }

  public void setEscapeProcessing(boolean bEscapeProcessing) throws SQLException {
    statement.setEscapeProcessing(bEscapeProcessing);
  }

  public void setFetchDirection(int iFetchDirection) throws SQLException {
    statement.setFetchDirection(iFetchDirection);
  }

  public void setFetchSize(int iFecthSize) throws SQLException {
    statement.setFetchSize(iFecthSize);
  }

  public void setMaxFieldSize(int iMax) throws SQLException {
    statement.setMaxFieldSize(iMax);
  }

  public void setMaxRows(int iMax) throws SQLException {
    statement.setMaxRows(iMax);
  }

  public void setQueryTimeout(int iTimeOut) throws SQLException {
    statement.setQueryTimeout(iTimeOut);
  }

  private String getConnectionTag() {
    if (sTag == null) return null;
    int i = sTag.indexOf("@");
    if (i >= 0) return sTag.substring(i + 1);
    return null;
  }

  public <T> T unwrap(Class<T> iface) throws SQLException {
    return statement.unwrap(iface);
  }

  public boolean isWrapperFor(Class<?> iface) throws SQLException {
    return statement.isWrapperFor(iface);
  }

  public boolean isClosed() throws SQLException {
    return statement.isClosed();
  }

  public void setPoolable(boolean poolable) throws SQLException {
    statement.setPoolable(poolable);
  }

  public boolean isPoolable() throws SQLException {
    return statement.isPoolable();
  }

  public void closeOnCompletion() throws SQLException {
    statement.closeOnCompletion();
  }

  public boolean isCloseOnCompletion() throws SQLException {
    return statement.isCloseOnCompletion();
  }
}
