package org.dew.jdbc;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Connection;
import java.sql.Statement;

public class TStatement implements Statement {

	private String sTag = null;
	private Statement statement;
	private Tracer tracer;
	protected String sDBMS;

	public TStatement(Statement statement, String sTag, Tracer tracer, String sDBMS) {
		this.statement = statement;
		this.sTag = sTag;
		this.tracer = tracer;
		this.sDBMS = sDBMS;
	}

	public void addBatch(String sSQL) throws java.sql.SQLException {
		statement.addBatch(sSQL);
	}

	public void cancel() throws java.sql.SQLException {
		statement.cancel();
	}

	public void clearBatch() throws java.sql.SQLException {
		statement.clearBatch();
	}

	public void clearWarnings() throws java.sql.SQLException {
		statement.clearWarnings();
	}

	public void close() throws java.sql.SQLException {
		tracer.traceRem("[" + sTag + ".close()]");
		try {
			statement.close();
		} catch (SQLException ex) {
			tracer.traceException(ex);
			throw ex;
		}
	}

	public boolean execute(String sSQL) throws java.sql.SQLException {
		boolean bResult = false;
		tracer.traceRem("[" + sTag + ".execute]");
		tracer.trace(sSQL.trim() + ";");
		long lBeginTime = System.currentTimeMillis();
		try {
			bResult = statement.execute(sSQL);
		} catch (SQLException ex) {
			tracer.traceException(ex);
			throw ex;
		}
		long lEndTime = System.currentTimeMillis();
		long lElapsed = lEndTime - lBeginTime;
		tracer.traceRem("Elapsed: " + lElapsed + " [ms].");
		return bResult;
	}

	public boolean execute(String sSQL, int autoGeneratedKeys) throws SQLException {
		boolean bResult = false;
		tracer.traceRem("[" + sTag + ".execute]");
		tracer.trace(sSQL.trim() + ";");
		long lBeginTime = System.currentTimeMillis();
		try {
			bResult = statement.execute(sSQL, autoGeneratedKeys);
		} catch (SQLException ex) {
			tracer.traceException(ex);
			throw ex;
		}
		long lEndTime = System.currentTimeMillis();
		long lElapsed = lEndTime - lBeginTime;
		tracer.traceRem("Elapsed: " + lElapsed + " [ms].");
		return bResult;
	}

	public boolean execute(String sSQL, int[] columnIndexes) throws SQLException {
		boolean bResult = false;
		tracer.traceRem("[" + sTag + ".execute]");
		tracer.trace(sSQL.trim() + ";");
		long lBeginTime = System.currentTimeMillis();
		try {
			bResult = statement.execute(sSQL, columnIndexes);
		} catch (SQLException ex) {
			tracer.traceException(ex);
			throw ex;
		}
		long lEndTime = System.currentTimeMillis();
		long lElapsed = lEndTime - lBeginTime;
		tracer.traceRem("Elapsed: " + lElapsed + " [ms].");
		return bResult;
	}

	public boolean execute(String sSQL, String[] columnNames) throws SQLException {
		boolean bResult = false;
		tracer.traceRem("[" + sTag + ".execute]");
		tracer.trace(sSQL.trim() + ";");
		long lBeginTime = System.currentTimeMillis();
		try {
			bResult = statement.execute(sSQL, columnNames);
		} catch (SQLException ex) {
			tracer.traceException(ex);
			throw ex;
		}
		long lEndTime = System.currentTimeMillis();
		long lElapsed = lEndTime - lBeginTime;
		tracer.traceRem("Elapsed: " + lElapsed + " [ms].");
		return bResult;
	}

	public int[] executeBatch() throws java.sql.SQLException {
		int[] aiResult = null;
		tracer.traceRem("[" + sTag + ".executeBatch]");
		try {
			aiResult = statement.executeBatch();
		} catch (SQLException ex) {
			tracer.traceException(ex);
			throw ex;
		}
		return aiResult;
	}

	public ResultSet executeQuery(String sSQL) throws java.sql.SQLException {
		ResultSet rs = null;
		tracer.traceRem("[" + sTag + ".executeQuery]");
		tracer.trace(sSQL.trim() + ";");
		long lBeginTime = System.currentTimeMillis();
		try {
			rs = statement.executeQuery(sSQL);
		} catch (SQLException ex) {
			tracer.traceException(ex);
			throw ex;
		}
		long lEndTime = System.currentTimeMillis();
		long lElapsed = lEndTime - lBeginTime;
		tracer.traceRem("Elapsed: " + lElapsed + " [ms].");
		return rs;
	}

	public int executeUpdate(String sSQL) throws java.sql.SQLException {
		int iUpdateCount = 0;
		tracer.traceRem("[" + sTag + ".executeUpdate]");
		tracer.trace(sSQL.trim() + ";");
		long lBeginTime = System.currentTimeMillis();
		try {
			iUpdateCount = statement.executeUpdate(sSQL);
		} catch (SQLException ex) {
			tracer.traceException(ex);
			throw ex;
		}
		long lEndTime = System.currentTimeMillis();
		long lElapsed = lEndTime - lBeginTime;
		tracer.traceRem(iUpdateCount + " rows affected, Elapsed: " + lElapsed + " [ms].");
		return iUpdateCount;
	}

	public int executeUpdate(String sSQL, int autoGeneratedKeys) throws SQLException {
		int iUpdateCount = 0;
		tracer.traceRem("[" + sTag + ".executeUpdate]");
		tracer.trace(sSQL.trim() + ";");
		long lBeginTime = System.currentTimeMillis();
		try {
			iUpdateCount = statement.executeUpdate(sSQL, autoGeneratedKeys);
		} catch (SQLException ex) {
			tracer.traceException(ex);
			throw ex;
		}
		long lEndTime = System.currentTimeMillis();
		long lElapsed = lEndTime - lBeginTime;
		tracer.traceRem(iUpdateCount + " rows affected, Elapsed: " + lElapsed + " [ms].");
		return iUpdateCount;
	}

	public int executeUpdate(String sSQL, int[] columnIndexes) throws SQLException {
		int iUpdateCount = 0;
		tracer.traceRem("[" + sTag + ".executeUpdate]");
		tracer.trace(sSQL.trim() + ";");
		long lBeginTime = System.currentTimeMillis();
		try {
			iUpdateCount = statement.executeUpdate(sSQL, columnIndexes);
		} catch (SQLException ex) {
			tracer.traceException(ex);
			throw ex;
		}
		long lEndTime = System.currentTimeMillis();
		long lElapsed = lEndTime - lBeginTime;
		tracer.traceRem(iUpdateCount + " rows affected, Elapsed: " + lElapsed + " [ms].");
		return iUpdateCount;
	}

	public int executeUpdate(String sSQL, String[] columnNames) throws SQLException {
		int iUpdateCount = 0;
		tracer.traceRem("[" + sTag + ".executeUpdate]");
		tracer.trace(sSQL.trim() + ";");
		long lBeginTime = System.currentTimeMillis();
		try {
			iUpdateCount = statement.executeUpdate(sSQL, columnNames);
		} catch (SQLException ex) {
			tracer.traceException(ex);
			throw ex;
		}
		long lEndTime = System.currentTimeMillis();
		long lElapsed = lEndTime - lBeginTime;
		tracer.traceRem(iUpdateCount + " rows affected, Elapsed: " + lElapsed + " [ms].");
		return iUpdateCount;
	}

	public Connection getConnection() throws java.sql.SQLException {
		Connection conn = statement.getConnection();
		return new TConnection(conn, getConnectionTag(), tracer, sDBMS);
	}

	public int getFetchDirection() throws java.sql.SQLException {
		return statement.getFetchDirection();
	}

	public int getFetchSize() throws java.sql.SQLException {
		return statement.getFetchSize();
	}

	public ResultSet getGeneratedKeys() throws SQLException {
		return statement.getGeneratedKeys();
	}

	public int getMaxFieldSize() throws java.sql.SQLException {
		return statement.getMaxFieldSize();
	}

	public int getMaxRows() throws java.sql.SQLException {
		return statement.getMaxRows();
	}

	public boolean getMoreResults() throws java.sql.SQLException {
		return statement.getMoreResults();
	}

	public boolean getMoreResults(int current) throws SQLException {
		return statement.getMoreResults(current);
	}

	public int getQueryTimeout() throws java.sql.SQLException {
		return statement.getQueryTimeout();
	}

	public ResultSet getResultSet() throws java.sql.SQLException {
		return statement.getResultSet();
	}

	public int getResultSetConcurrency() throws java.sql.SQLException {
		return statement.getResultSetConcurrency();
	}

	public int getResultSetHoldability() throws SQLException {
		return statement.getResultSetHoldability();
	}

	public int getResultSetType() throws java.sql.SQLException {
		return statement.getResultSetType();
	}

	public int getUpdateCount() throws java.sql.SQLException {
		return statement.getUpdateCount();
	}

	public SQLWarning getWarnings() throws java.sql.SQLException {
		return statement.getWarnings();
	}

	public void setCursorName(String sCursorName) throws java.sql.SQLException {
		statement.setCursorName(sCursorName);
	}

	public void setEscapeProcessing(boolean bEscapeProcessing) throws java.sql.SQLException {
		statement.setEscapeProcessing(bEscapeProcessing);
	}

	public void setFetchDirection(int iFetchDirection) throws java.sql.SQLException {
		statement.setFetchDirection(iFetchDirection);
	}

	public void setFetchSize(int iFecthSize) throws java.sql.SQLException {
		statement.setFetchSize(iFecthSize);
	}

	public void setMaxFieldSize(int iMax) throws java.sql.SQLException {
		statement.setMaxFieldSize(iMax);
	}

	public void setMaxRows(int iMax) throws java.sql.SQLException {
		statement.setMaxRows(iMax);
	}

	public void setQueryTimeout(int iTimeOut) throws java.sql.SQLException {
		statement.setQueryTimeout(iTimeOut);
	}

	private String getConnectionTag() {
		if (sTag == null)
			return null;
		int i = sTag.indexOf("@");
		if (i >= 0)
			return sTag.substring(i + 1);
		return null;
	}

	public <T> T unwrap(Class<T> iface) throws SQLException {
		return statement.unwrap(iface);
	}

	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return statement.isWrapperFor(iface);
	}

	public boolean isClosed() throws SQLException {
		return statement.isClosed();
	}

	public void setPoolable(boolean poolable) throws SQLException {
		statement.setPoolable(poolable);
	}

	public boolean isPoolable() throws SQLException {
		return statement.isPoolable();
	}

	public void closeOnCompletion() throws SQLException {
		statement.closeOnCompletion();
	}

	public boolean isCloseOnCompletion() throws SQLException {
		return statement.isCloseOnCompletion();
	}
}
