package org.dew.jdbc;

import java.io.InputStream;
import java.io.Reader;

import java.math.BigDecimal;

import java.net.URL;

import java.sql.*;

import java.util.Calendar;

public class TPreparedStatement implements PreparedStatement {

  protected TMap mapParameters;
  protected PreparedStatement pstm;
  protected String sPreparedSQL;
  protected String sTag = null;
  protected Tracer tracer;
  protected String sDBMS;

  public TPreparedStatement(PreparedStatement pstm, String sPreparedSQL, String sTag, Tracer tracer, String sDBMS) {
    this.pstm = pstm;
    this.sPreparedSQL = sPreparedSQL;
    this.sTag = sTag;
    this.tracer = tracer;
    this.sDBMS = sDBMS;
    
    mapParameters = new TMap(sDBMS);
  }

  public void addBatch() throws SQLException {
    tracer.info("[" + sTag + ".addBatch]");
    pstm.addBatch();
  }

  public void addBatch(String sSQL) throws SQLException {
    tracer.info("[" + sTag + ".addBatch(" + sSQL + ")]");
    pstm.addBatch(sSQL);
  }

  public void cancel() throws SQLException {
    tracer.info("[" + sTag + ".cancel]");
    pstm.cancel();
  }

  public void clearBatch() throws SQLException {
    tracer.info("[" + sTag + ".clearBatch]");
    pstm.clearBatch();
  }

  public void clearParameters() throws SQLException {
    tracer.info("[" + sTag + ".clearParameters]");
    mapParameters.clear();
    pstm.clearParameters();
  }

  public void clearWarnings() throws SQLException {
    tracer.info("[" + sTag + ".clearWarnings]");
    pstm.clearWarnings();
  }

  public void close() throws SQLException {
    tracer.info("[" + sTag + ".close()]");
    try {
      pstm.close();
    } catch (SQLException ex) {
      tracer.error(ex);
      throw ex;
    }
  }

  public boolean execute() throws SQLException {
    boolean bResult = false;
    tracer.info("[" + sTag + ".execute {SQL = " + sPreparedSQL + "}]");
    tracer.info("[parameters: " + mapParameters + "]");
    String sTransSQL = mapParameters.transSQL(sPreparedSQL);
    tracer.debug(sTransSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      bResult = pstm.execute();
    } catch (SQLException ex) {
      tracer.error(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.info("Elapsed: " + lElapsed + " [ms].");
    return bResult;
  }

  public boolean execute(String sSQL) throws SQLException {
    boolean bResult = false;
    tracer.info("[" + sTag + ".execute]");
    tracer.debug(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      bResult = pstm.execute(sSQL);
    } catch (SQLException ex) {
      tracer.error(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.info("Elapsed: " + lElapsed + " [ms].");
    return bResult;
  }

  public boolean execute(String sSQL, int autoGeneratedKeys) throws SQLException {
    boolean bResult = false;
    tracer.info("[" + sTag + ".execute]");
    tracer.debug(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      bResult = pstm.execute(sSQL, autoGeneratedKeys);
    } catch (SQLException ex) {
      tracer.error(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.info("Elapsed: " + lElapsed + " [ms].");
    return bResult;
  }

  public boolean execute(String sSQL, int[] columnIndexes) throws SQLException {
    boolean bResult = false;
    tracer.info("[" + sTag + ".execute]");
    tracer.debug(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      bResult = pstm.execute(sSQL, columnIndexes);
    } catch (SQLException ex) {
      tracer.error(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.info("Elapsed: " + lElapsed + " [ms].");
    return bResult;
  }

  public boolean execute(String sSQL, String[] columnNames) throws SQLException {
    boolean bResult = false;
    tracer.info("[" + sTag + ".execute]");
    tracer.debug(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      bResult = pstm.execute(sSQL, columnNames);
    } catch (SQLException ex) {
      tracer.error(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.info("Elapsed: " + lElapsed + " [ms].");
    return bResult;
  }

  public int[] executeBatch() throws SQLException {
    int[] aiResult = null;
    tracer.info("[" + sTag + ".executeBatch]");
    try {
      aiResult = pstm.executeBatch();
    } catch (SQLException ex) {
      tracer.error(ex);
      throw ex;
    }
    return aiResult;
  }

  public ResultSet executeQuery() throws SQLException {
    ResultSet rs = null;
    tracer.info("[" + sTag + ".executeQuery {SQL = " + sPreparedSQL + "}]");
    tracer.info("[parameters: " + mapParameters + "]");
    String sTransSQL = mapParameters.transSQL(sPreparedSQL);
    tracer.debug(sTransSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      rs = pstm.executeQuery();
    } catch (SQLException ex) {
      tracer.error(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.info("Elapsed: " + lElapsed + " [ms].");
    return rs;
  }

  public ResultSet executeQuery(String sSQL) throws SQLException {
    ResultSet rs = null;
    tracer.info("[" + sTag + ".executeQuery]");
    tracer.debug(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      rs = pstm.executeQuery(sSQL + ";");
    } catch (SQLException ex) {
      tracer.error(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.info("Elapsed: " + lElapsed + " [ms].");
    return rs;
  }

  public int executeUpdate() throws SQLException {
    int iUpdateCount = 0;
    tracer.info("[" + sTag + ".executeUpdate {SQL = " + sPreparedSQL + "}]");
    tracer.info("[parameters: " + mapParameters + "]");
    String sTransSQL = mapParameters.transSQL(sPreparedSQL);
    tracer.debug(sTransSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      iUpdateCount = pstm.executeUpdate();
    } catch (SQLException ex) {
      tracer.error(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.info(iUpdateCount + " rows affected, Elapsed: " + lElapsed + " [ms].");
    return iUpdateCount;
  }

  public int executeUpdate(String sSQL) throws SQLException {
    int iUpdateCount = 0;
    tracer.info("[" + sTag + ".executeUpdate]");
    tracer.debug(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      iUpdateCount = pstm.executeUpdate(sSQL);
    } catch (SQLException ex) {
      tracer.error(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.info(iUpdateCount + " rows affected, Elapsed: " + lElapsed + " [ms].");
    return iUpdateCount;
  }

  public int executeUpdate(String sSQL, int autoGeneratedKeys) throws SQLException {
    int iUpdateCount = 0;
    tracer.info("[" + sTag + ".executeUpdate]");
    tracer.debug(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      iUpdateCount = pstm.executeUpdate(sSQL, autoGeneratedKeys);
    } catch (SQLException ex) {
      tracer.error(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.info(iUpdateCount + " rows affected, Elapsed: " + lElapsed + " [ms].");
    return iUpdateCount;
  }

  public int executeUpdate(String sSQL, int[] columnIndexes) throws SQLException {
    int iUpdateCount = 0;
    tracer.info("[" + sTag + ".executeUpdate]");
    tracer.debug(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      iUpdateCount = pstm.executeUpdate(sSQL, columnIndexes);
    } catch (SQLException ex) {
      tracer.error(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.info(iUpdateCount + " rows affected, Elapsed: " + lElapsed + " [ms].");
    return iUpdateCount;
  }

  public int executeUpdate(String sSQL, String[] columnNames) throws SQLException {
    int iUpdateCount = 0;
    tracer.info("[" + sTag + ".executeUpdate]");
    tracer.debug(sSQL.trim() + ";");
    long lBeginTime = System.currentTimeMillis();
    try {
      iUpdateCount = pstm.executeUpdate(sSQL, columnNames);
    } catch (SQLException ex) {
      tracer.error(ex);
      throw ex;
    }
    long lEndTime = System.currentTimeMillis();
    long lElapsed = lEndTime - lBeginTime;
    tracer.info(iUpdateCount + " rows affected, Elapsed: " + lElapsed + " [ms].");
    return iUpdateCount;
  }

  public Connection getConnection() throws SQLException {
    Connection conn = pstm.getConnection();
    return new TConnection(conn, getConnectionTag(), tracer, sDBMS);
  }

  public int getFetchDirection() throws SQLException {
    return pstm.getFetchDirection();
  }

  public int getFetchSize() throws SQLException {
    return pstm.getFetchSize();
  }

  public ResultSet getGeneratedKeys() throws SQLException {
    return pstm.getGeneratedKeys();
  }

  public int getMaxFieldSize() throws SQLException {
    return pstm.getMaxFieldSize();
  }

  public int getMaxRows() throws SQLException {
    return pstm.getMaxRows();
  }

  public ResultSetMetaData getMetaData() throws SQLException {
    return pstm.getMetaData();
  }

  public boolean getMoreResults() throws SQLException {
    return pstm.getMoreResults();
  }

  public boolean getMoreResults(int current) throws SQLException {
    return pstm.getMoreResults(current);
  }

  public ParameterMetaData getParameterMetaData() throws SQLException {
    return pstm.getParameterMetaData();
  }

  public int getQueryTimeout() throws SQLException {
    return pstm.getQueryTimeout();
  }

  public ResultSet getResultSet() throws SQLException {
    return pstm.getResultSet();
  }

  public int getResultSetConcurrency() throws SQLException {
    return pstm.getResultSetConcurrency();
  }

  public int getResultSetHoldability() throws SQLException {
    return pstm.getResultSetHoldability();
  }

  public int getResultSetType() throws SQLException {
    return pstm.getResultSetType();
  }

  public int getUpdateCount() throws SQLException {
    return pstm.getUpdateCount();
  }

  public SQLWarning getWarnings() throws SQLException {
    return pstm.getWarnings();
  }

  public void setArray(int iIndex, Array par) throws SQLException {
    pstm.setArray(iIndex, par);
  }

  public void setAsciiStream(int iIndex, InputStream par, int iLenght) throws SQLException {
    pstm.setAsciiStream(iIndex, par, iLenght);
  }

  public void setBigDecimal(int iIndex, BigDecimal par) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setBigDecimal(iIndex, par);
  }

  public void setBinaryStream(int iIndex, InputStream par, int iLenght) throws SQLException {
    pstm.setBinaryStream(iIndex, par, iLenght);
  }

  public void setBlob(int iIndex, Blob par) throws SQLException {
    mapParameters.put(iIndex, "<Blob>");
    pstm.setBlob(iIndex, par);
  }

  public void setBoolean(int iIndex, boolean par) throws SQLException {
    mapParameters.put(iIndex, par ? 1 : 0);
    pstm.setBoolean(iIndex, par);
  }

  public void setByte(int iIndex, byte par) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setByte(iIndex, par);
  }

  public void setBytes(int iIndex, byte[] par) throws SQLException {
    mapParameters.put(iIndex, "<byte[]>");
    pstm.setBytes(iIndex, par);
  }

  public void setCharacterStream(int iIndex, Reader par, int iLenght) throws SQLException {
    pstm.setCharacterStream(iIndex, par, iLenght);
  }

  public void setClob(int iIndex, Clob par) throws SQLException {
    mapParameters.put(iIndex, "<Clob>");
    pstm.setClob(iIndex, par);
  }

  public void setCursorName(String sCursorName) throws SQLException {
    pstm.setCursorName(sCursorName);
  }

  public void setDate(int iIndex, Date par) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setDate(iIndex, par);
  }

  public void setDate(int iIndex, Date par, Calendar cal) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setDate(iIndex, par, cal);
  }

  public void setDouble(int iIndex, double par) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setDouble(iIndex, par);
  }

  public void setEscapeProcessing(boolean bPar) throws SQLException {
    pstm.setEscapeProcessing(bPar);
  }

  public void setFetchDirection(int iFetchDirection) throws SQLException {
    pstm.setFetchDirection(iFetchDirection);
  }

  public void setFetchSize(int iFetchSize) throws SQLException {
    pstm.setFetchSize(iFetchSize);
  }

  public void setFloat(int iIndex, float par) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setFloat(iIndex, par);
  }

  public void setInt(int iIndex, int par) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setInt(iIndex, par);
  }

  public void setLong(int iIndex, long par) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setLong(iIndex, par);
  }

  public void setMaxFieldSize(int iMax) throws SQLException {
    pstm.setMaxFieldSize(iMax);
  }

  public void setMaxRows(int iMaxRows) throws SQLException {
    pstm.setMaxRows(iMaxRows);
  }

  public void setNull(int iIndex, int par) throws SQLException {
    pstm.setNull(iIndex, par);
  }

  public void setNull(int iIndex, int par, String sTypeName) throws SQLException {
    mapParameters.put(iIndex, null);
    pstm.setNull(iIndex, par, sTypeName);
  }

  public void setObject(int iIndex, Object par) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setObject(iIndex, par);
  }

  public void setObject(int iIndex, Object par, int iTargetSQLType) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setObject(iIndex, par, iTargetSQLType);
  }

  public void setObject(int iIndex, Object par, int iTargetSQLType, int iScale) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setObject(iIndex, par, iTargetSQLType, iScale);
  }

  public void setQueryTimeout(int iTimeOut) throws SQLException {
    pstm.setQueryTimeout(iTimeOut);
  }

  public void setRef(int iIndex, Ref par) throws SQLException {
    pstm.setRef(iIndex, par);
  }

  public void setShort(int iIndex, short par) throws SQLException {
    pstm.setShort(iIndex, par);
  }

  public void setString(int iIndex, String par) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setString(iIndex, par);
  }

  public void setTime(int iIndex, Time par) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setTime(iIndex, par);
  }

  public void setTime(int iIndex, Time par, Calendar cal) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setTime(iIndex, par, cal);
  }

  public void setTimestamp(int iIndex, Timestamp par) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setTimestamp(iIndex, par);
  }

  public void setTimestamp(int iIndex, Timestamp par, Calendar cal) throws SQLException {
    mapParameters.put(iIndex, par);
    pstm.setTimestamp(iIndex, par, cal);
  }

  @SuppressWarnings("deprecation")
  public void setUnicodeStream(int iIndex, InputStream par, int iLenght) throws SQLException {
    pstm.setUnicodeStream(iIndex, par, iLenght);
  }

  public void setURL(int parameterIndex, URL x) throws SQLException {
    mapParameters.put(parameterIndex, x);
    pstm.setURL(parameterIndex, x);
  }

  private String getConnectionTag() {
    if (sTag == null) return null;
    int i = sTag.indexOf("@");
    if (i >= 0) return sTag.substring(i + 1);
    return null;
  }

  public boolean isClosed() throws SQLException {
    return pstm.isClosed();
  }

  public void setPoolable(boolean poolable) throws SQLException {
    tracer.info("[" + sTag + ".setPoolable(" + poolable + ")]");
    pstm.setPoolable(poolable);
  }

  public boolean isPoolable() throws SQLException {
    return pstm.isPoolable();
  }

  public void closeOnCompletion() throws SQLException {
    tracer.info("[" + sTag + ".closeOnCompletion]");
    pstm.closeOnCompletion();
  }

  public boolean isCloseOnCompletion() throws SQLException {
    return pstm.isCloseOnCompletion();
  }

  public <T> T unwrap(Class<T> iface) throws SQLException {
    return pstm.unwrap(iface);
  }

  public boolean isWrapperFor(Class<?> iface) throws SQLException {
    return pstm.isWrapperFor(iface);
  }

  public void setRowId(int parameterIndex, RowId x) throws SQLException {
    pstm.setRowId(parameterIndex, x);
  }

  public void setNString(int parameterIndex, String value) throws SQLException {
    mapParameters.put(parameterIndex, value);
    pstm.setNString(parameterIndex, value);
  }

  public void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException {
    pstm.setNCharacterStream(parameterIndex, value);
  }

  public void setNClob(int parameterIndex, NClob value) throws SQLException {
    pstm.setNClob(parameterIndex, value);
  }

  public void setClob(int parameterIndex, Reader reader, long length) throws SQLException {
    pstm.setClob(parameterIndex, reader, length);
  }

  public void setBlob(int parameterIndex, InputStream inputStream, long length) throws SQLException {
    pstm.setBlob(parameterIndex, inputStream, length);
  }

  public void setNClob(int parameterIndex, Reader reader, long length) throws SQLException {
    pstm.setNClob(parameterIndex, reader, length);
  }

  public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
    pstm.setSQLXML(parameterIndex, xmlObject);
  }

  public void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException {
    pstm.setAsciiStream(parameterIndex, x, length);
  }

  public void setBinaryStream(int parameterIndex, InputStream x, long length) throws SQLException {
    pstm.setBinaryStream(parameterIndex, x);
  }

  public void setCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
    pstm.setCharacterStream(parameterIndex, reader, length);
  }

  public void setAsciiStream(int parameterIndex, InputStream x) throws SQLException {
    pstm.setAsciiStream(parameterIndex, x);
  }

  public void setBinaryStream(int parameterIndex, InputStream x) throws SQLException {
    pstm.setBinaryStream(parameterIndex, x);
  }

  public void setCharacterStream(int parameterIndex, Reader reader) throws SQLException {
    pstm.setCharacterStream(parameterIndex, reader);
  }

  public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException {
    pstm.setNCharacterStream(parameterIndex, value);
  }

  public void setClob(int parameterIndex, Reader reader) throws SQLException {
    pstm.setClob(parameterIndex, reader);
  }

  public void setBlob(int parameterIndex, InputStream inputStream) throws SQLException {
    pstm.setBlob(parameterIndex, inputStream);
  }

  public void setNClob(int parameterIndex, Reader reader) throws SQLException {
    pstm.setNClob(parameterIndex, reader);
  }
}